% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ssa.R
\name{ssa}
\alias{ssa}
\title{Invoking the stochastic simulation algorithm}
\usage{
ssa(initial_state, propensity_funs, nu, final_time, params = NULL,
  method = ssa_direct(), census_interval = 0,
  stop_on_neg_state = TRUE, max_walltime = Inf,
  hardcode_params = FALSE, verbose = FALSE, console_interval = 1,
  use_singular_optimisation = FALSE)
}
\arguments{
\item{initial_state}{\code{[named numeric vector]} The initial state to start the simulation with.}

\item{propensity_funs}{\code{[character vector]} A character representation of the propensity functions, written in C++.
Check the sections below for more information on how to define the propensity functions.}

\item{nu}{\code{[numeric matrix]} The changes in number of individuals in a state (rows) caused
by a single reaction (columns).}

\item{final_time}{\code{[numeric]} The final simulation time.}

\item{params}{\code{[named numeric vector]} Constant parameters to be used in the propensity functions.}

\item{method}{\code{[SSA]}] Which SSA algorithm to use. Must be one of: \code{\link[=ssa_direct]{ssa_direct()}},
\code{\link[=ssa_btl]{ssa_btl()}}, or \code{\link[=ssa_etl]{ssa_etl()}}.}

\item{census_interval}{\code{[numeric]} The approximate interval between recording the state of the system.
Setting this parameter to \code{0} will cause each state to be recorded, and
to \code{Inf} will cause only the end state to be recorded.}

\item{stop_on_neg_state}{\code{[logical]} Whether or not to stop the simulation when
the a negative value in the state has occured. This can occur, for instance, in the \code{\link[=ssa_etl]{ssa_etl()}}
method.}

\item{max_walltime}{\code{[numeric]} The maximum duration (in seconds) that the
simulation is allowed to run for before terminated.}

\item{hardcode_params}{\code{[logical]} Whether or not to hardcode the values of \code{params} in the compilation of the \code{propensity_funs}.
Setting this to \code{TRUE} will result in a minor sacrifice in accuracy for a minor increase in performance.}

\item{verbose}{\code{[logical]} If \code{TRUE}, intermediary information pertaining to the simulation will be displayed.}

\item{console_interval}{\code{[numeric]} The approximate interval between intermediary information outputs.}

\item{use_singular_optimisation}{\code{[logical]} An experimental optimisation. Do not use yet.}
}
\value{
Returns a list object with the following elements:
\itemize{
\item \code{time}: \code{[numeric]} Simulatiom time for each recorded timepoint.
\item \code{state}: \code{[numeric matrix]} The state values for each of the timepoints.
\item \code{propensity}: \code{[numeric matrix]} The propensity values for each of the timepoints.
\item \code{buffer}: \code{[numeric matrix]} The temporary calculation buffer used as part of the propensity functions.
}
}
\description{
Main interface function to the implemented \acronym{SSA} methods. Runs a
single realization of a predefined system.
}
\details{
Substantial improvements in speed and accuracy can be obtained by
adjusting the additional (and optional) \code{ssa} arguments. By default
\code{ssa} (tries to) use conservative default values for the these
arguments, prioritizing computational accuracy over computational speed.
These default values are, however, \strong{not} fool proof for the
approximate methods, and occasionally one will have to hand tweak them in
order for a stochastic model to run appropriately.
}
\note{
Selecting the appropriate \acronym{SSA} method is a trade-off between
computational speed, accuracy of the results, and which \acronym{SSA}
actually works for a given scenario. This depends on the characteristics of
the defined system (e.g. number of reaction channels, number of species, and
the absolute and relative magnitude of the propensity functions).
\strong{Not all methods are appropriate for all models.} When selecting a
\acronym{SSA} method all of these factors have to be taken into
consideration. The various tau-leap methods accept a number of additional
arguments. While the default values of these arguments may work for some
scenarios they may have to be adjusted for others. The default values for
the tau-leap methods are conservative in terms of computational speed and
substantial increase in efficiency may be gained by optimizing their values
for a specific system.
}
\section{Preparing a run}{
 In order to invoke \acronym{SSA} the stochastic
model needs at least four components, the initial state vector (\code{initial.state}),
state-change matrix (\code{nu}), propensity vector (\code{a}), and the final
time of the simulation (\code{final.time}). The initial state vector defines the
population sizes in all the states at \eqn{t = 0}, e.g. for a system with two
species \code{X1} and \code{X2} where both have an initial population size
of 1000 the initial state vector is defined as \code{initial.state <- c(X1 = 1000,X2 = 1000)}. The elements of the vector have to be labelled using
the same notation as the state variables used in the propensity functions.
The state-change matrix defines the change in the number of individuals in
each state (rows) as caused by one reaction of a given type (columns). For
example, the state-change matrix for system with the species \eqn{S_1}{S1}
and \eqn{S_2}{S2} with two reactions \deqn{S_1
  \stackrel{c_1}{\longrightarrow} S_2}{S1 --c1--> S2} \deqn{S_2
  \stackrel{c_2}{\longrightarrow} 0}{S2 --c2--> 0}

is defined as \code{nu <- matrix(c(-1,0,+1,-1),nrow = 2,byrow = TRUE)} where
\eqn{c_1}{c1} and \eqn{c_2}{c2} are the per capita reaction probabilities.
The propensity vector, \code{a}, defines the probabilities that a particular
reaction will occur over the next infinitesimal time interval \eqn{\left[
  t,t+dt \right]}{[t,t+dt]}. For example, in the previous example the
propensity vector is defined as \code{a <- c("c1*X1","c2*X2")}. The
propensity vector consists of character elements of each reaction's
propensity function where each state variable requires the corresponding
named element label in the initial state vector (\code{initial.state}).
}

\examples{
## Irreversible isomerization
## Large initial population size (X = 1000)
\dontrun{
params <- c(c = 0.5)
initial_state <- c(X = 1000)
propensity_funs <- c("A = c * X")
nu <- matrix(-1, dimnames = list(names(initial_state), "A"))
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 10,
  method = ssa_direct()
)
ssa_plot(out)
}

## Smaller initial population size (X = 100)
\dontrun{
initial_state <- c(X = 100)
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 10,
  method = ssa_direct()
)
ssa_plot(out)
}

## Small initial population size (X = 10)
\dontrun{
initial_state <- c(X = 10)
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 10,
  method = ssa_direct()
)
ssa_plot(out)
}

## Logistic growth
\dontrun{
params <- c(b = 2, d = 1, K = 1000)
initial_state  <- c(N = 500)
propensity_funs <- c(
  "A = b * N",
  "B = (d + (b - d) * N / K) * N"
)
nu  <- matrix(
  c(+1, -1),
  ncol = 2,
  dimnames = list(names(initial_state), c("A", "B"))
)
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 10,
  max_walltime = 5,
  method = ssa_direct()
)
ssa_plot(out)
}

## Kermack-McKendrick SIR model
\dontrun{
params <- c(beta = 0.001, gamma = 0.1)
initial_state  <- c(S = 500, I = 1, R = 0)
propensity_funs <- c(
  "A = beta * S * I",
  "B = gamma * I"
)
nu <- matrix(
  c(
    -1, 0,
    +1, -1,
    0, +1
  ),
  nrow = 3,
  byrow = TRUE,
  dimnames = list(names(initial_state), c("A", "B"))
)
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 100,
  method = ssa_direct(),
  census_interval = 0.01
)
ssa_plot(out)
}

## Lotka predator-prey model
\dontrun{
params <- c(c1 = 10, c2 = .01, c3 = 10)
initial_state <- c(Y1 = 1000, Y2 = 1000)
propensity_funs <- c(
  "A = c1 * Y1",
  "B = c2 * Y1 * Y2",
  "C = c3 * Y2"
)
nu <- matrix(
  c(
    +1, -1, 0,
    0, +1, -1
  ),
  nrow = 2,
  byrow = TRUE,
  dimnames = list(names(initial_state), c("A", "B", "C"))
)
out <- ssa(
  initial_state = initial_state,
  propensity_funs = propensity_funs,
  nu = nu,
  params = params,
  final_time = 100,
  method = ssa_direct(),
  census_interval = .01,
  verbose = TRUE
)
ssa_plot(out)
}

}
\seealso{
\link{package}, \code{\link[=ssa_direct]{ssa_direct()}}, \code{\link[=ssa_etl]{ssa_etl()}}, \code{\link[=ssa_btl]{ssa_btl()}}
}
